{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This guide serves as a reference for common tools and topics used when programming for the First Tech Challenge. We hope that both beginner and more advanced teams can learn something from this. Contributors:","title":"Home"},{"location":"closed-loop/","text":"Closed loop control is used very commonly in FTC, and robotics in general. It is used to have full control over systems on the robot, and make sure they are performing the way the programmer intended. There are a few important concepts to cover when it comes to closed-loop control, including PID, Feedforward, Pure pursuit, etc. Resources Below are some great resources that I recommend you look at when studying control theory: CTRLALTFTC Control Theory Bible Kookybotz PIDF Tutorial","title":"Closed Loop Control"},{"location":"closed-loop/#resources","text":"Below are some great resources that I recommend you look at when studying control theory: CTRLALTFTC Control Theory Bible Kookybotz PIDF Tutorial","title":"Resources"},{"location":"control/","text":"One of the most important concepts to understand when coding for any form of robotics or engineering is control theory. This concept allows you to have full control over a system, and a full understanding of this concept gives you the knowledge necessary to tackle a wide range of systems. For example, a motor can respond well to environmental feedback and change its power input accordingly. Open-loop control You have likely seen this form of control before. A motor is told to input a specific power for a specified duration of time. The motor will run for this period of time, and then stop. This example is illustrated below: // simple open-loop example motor.setPower(1); time(100) motor.setPower(0); In the above example, a motor is told to run for a specified duration, in this case 100 of some arbitrary unit. Although this type of control may have its uses, it is often not sufficient. This is because outside factors may influence the behaviour of the system, and cause it to stray the programmer's intended result. Closed-loop control In order to combat this problem, a closed loop system can be created. In this type of system, the input is directly influenced by the output. For example, a motor will be given an input power of 1 until the angle of the motor is 90 degrees. The motor will correct itself based on feedback. A proportional controller is a simple example of closed-loop control. The current position is referenced to the desired position, and error is calculated. The error is used as the input into the system, and slowly reaches 0. // simple proportional controller example target = 10; while(targetNotReached) { motorPosition = motor.getPosition(); error = target - motorPosition; motor.setPower(error); } On the next page, I'll be going more in depth into closed-loop control.","title":"Control Theory"},{"location":"control/#open-loop-control","text":"You have likely seen this form of control before. A motor is told to input a specific power for a specified duration of time. The motor will run for this period of time, and then stop. This example is illustrated below: // simple open-loop example motor.setPower(1); time(100) motor.setPower(0); In the above example, a motor is told to run for a specified duration, in this case 100 of some arbitrary unit. Although this type of control may have its uses, it is often not sufficient. This is because outside factors may influence the behaviour of the system, and cause it to stray the programmer's intended result.","title":"Open-loop control"},{"location":"control/#closed-loop-control","text":"In order to combat this problem, a closed loop system can be created. In this type of system, the input is directly influenced by the output. For example, a motor will be given an input power of 1 until the angle of the motor is 90 degrees. The motor will correct itself based on feedback. A proportional controller is a simple example of closed-loop control. The current position is referenced to the desired position, and error is calculated. The error is used as the input into the system, and slowly reaches 0. // simple proportional controller example target = 10; while(targetNotReached) { motorPosition = motor.getPosition(); error = target - motorPosition; motor.setPower(error); } On the next page, I'll be going more in depth into closed-loop control.","title":"Closed-loop control"},{"location":"drivetrain/","text":"The base of any FTC robot is the drivetrain, which is what enables the robot to move around. Drivetrains can be split into two types: differential and holonomic. Differential Differential, or tank, drivetrains typically use traction wheels, and do not possess the ability to strafe. They are usually easier to program, but limit mobility. An example can be seen below: As you can see, the tank drivetrain would not possess the ability to strafe due to the traction and omniwheels used. The above pictured drive would have the ability to move forwards and backwards, and turn. Lets go ahead and program movement for a tank drivetrain: @TeleOp public class DifferentialDrive extends LinearOpMode { @Override public void runOpMode() throws InterruptedException { // declare four motors for each of our wheels DcMotor frontLeft = hardwareMap.dcMotor.get(\"frontLeft\"); DcMotor frontRight = hardwareMap.dcMotor.get(\"frontRight\"); DcMotor backLeft = hardwareMap.dcMotor.get(\"backLeft\"); DcMotor backRight = hardwareMap.dcMotor.get(\"backRight\"); // reverse the right motors frontRight.setDirection(DcMotorSimple.Direction.REVERSE); backRight.setDirection(DcMotorSimple.Direction.REVERSE) waitForStart(); if(isStopRequested()) return; while(opModeIsActive()) { frontLeft.setPower(gamepad.left_stick_y); backLeft.setPower(gamepad.left_stick_y); frontRight.setPower(gamepad.right_stick_y); backRight.setPower(gamepad.right_stick_y); } } } Holonomic Most FTC teams use holonomic drives which allow for strafing. The mecanum drive, as pictured above, is commonly used in FTC. This type of drive uses special mecanum wheels whose rollers are tilted at a 45\u00b0 angle. When the wheels move in a specific arrangement, the drive strafes. Now let's write code for our mecanum drivetrain: @TeleOp public class MecanumDrive extends LinearOpMode { @Override public void runOpMode() throws InterruptedException { // declare four motors for each of our wheels DcMotor frontLeft = hardwareMap.dcMotor.get(\"frontLeft\"); DcMotor frontRight = hardwareMap.dcMotor.get(\"frontRight\"); DcMotor backLeft = hardwareMap.dcMotor.get(\"backLeft\"); DcMotor backRight = hardwareMap.dcMotor.get(\"backRight\"); // reverse the right motors frontRight.setDirection(DcMotorSimple.Direction.REVERSE); backRight.setDirection(DcMotorSimple.Direction.REVERSE) waitForStart(); if(isStopRequested()) return; while(opModeIsActive()) { frontLeft.setPower(gamepad.left_stick_y); backLeft.setPower(gamepad.left_stick_y); frontRight.setPower(gamepad.right_stick_y); backRight.setPower(gamepad.right_stick_y); move(gamepad.left_stick_y, gamepad.left_stick_x, gamepad.right_stick_x); } public void move(double power, double strafe, double turn) { double denominator = Math.max(Math.abs(power) + Math.abs(strafe) + Math.abs(turn), 1); double frontLeftPower = (power + strafe + turn) / denominator; double backLeftPower = (power - strafe + turn) / denominator; double frontRightPower = (power - strafe - turn) / denominator; double backRightPower = (power + strafe - turn) / denominator; setDrivePowers(frontLeftPower, backLeftPower, frontRightPower, backRightPower); } public void setDrivePowers(double frontLeftPower, double backLeftPower, double frontRightPower, double backRightPower) { leftFront.setPower(frontLeftPower); leftRear.setPower(backLeftPower); rightFront.setPower(frontRightPower); rightRear.setPower(backRightPower); } } } The mecanum drivetrain allows for much more freedom of movement, and makes quick manuevers during the teleop period possible.","title":"Drivetrains"},{"location":"drivetrain/#differential","text":"Differential, or tank, drivetrains typically use traction wheels, and do not possess the ability to strafe. They are usually easier to program, but limit mobility. An example can be seen below: As you can see, the tank drivetrain would not possess the ability to strafe due to the traction and omniwheels used. The above pictured drive would have the ability to move forwards and backwards, and turn. Lets go ahead and program movement for a tank drivetrain: @TeleOp public class DifferentialDrive extends LinearOpMode { @Override public void runOpMode() throws InterruptedException { // declare four motors for each of our wheels DcMotor frontLeft = hardwareMap.dcMotor.get(\"frontLeft\"); DcMotor frontRight = hardwareMap.dcMotor.get(\"frontRight\"); DcMotor backLeft = hardwareMap.dcMotor.get(\"backLeft\"); DcMotor backRight = hardwareMap.dcMotor.get(\"backRight\"); // reverse the right motors frontRight.setDirection(DcMotorSimple.Direction.REVERSE); backRight.setDirection(DcMotorSimple.Direction.REVERSE) waitForStart(); if(isStopRequested()) return; while(opModeIsActive()) { frontLeft.setPower(gamepad.left_stick_y); backLeft.setPower(gamepad.left_stick_y); frontRight.setPower(gamepad.right_stick_y); backRight.setPower(gamepad.right_stick_y); } } }","title":"Differential"},{"location":"drivetrain/#holonomic","text":"Most FTC teams use holonomic drives which allow for strafing. The mecanum drive, as pictured above, is commonly used in FTC. This type of drive uses special mecanum wheels whose rollers are tilted at a 45\u00b0 angle. When the wheels move in a specific arrangement, the drive strafes. Now let's write code for our mecanum drivetrain: @TeleOp public class MecanumDrive extends LinearOpMode { @Override public void runOpMode() throws InterruptedException { // declare four motors for each of our wheels DcMotor frontLeft = hardwareMap.dcMotor.get(\"frontLeft\"); DcMotor frontRight = hardwareMap.dcMotor.get(\"frontRight\"); DcMotor backLeft = hardwareMap.dcMotor.get(\"backLeft\"); DcMotor backRight = hardwareMap.dcMotor.get(\"backRight\"); // reverse the right motors frontRight.setDirection(DcMotorSimple.Direction.REVERSE); backRight.setDirection(DcMotorSimple.Direction.REVERSE) waitForStart(); if(isStopRequested()) return; while(opModeIsActive()) { frontLeft.setPower(gamepad.left_stick_y); backLeft.setPower(gamepad.left_stick_y); frontRight.setPower(gamepad.right_stick_y); backRight.setPower(gamepad.right_stick_y); move(gamepad.left_stick_y, gamepad.left_stick_x, gamepad.right_stick_x); } public void move(double power, double strafe, double turn) { double denominator = Math.max(Math.abs(power) + Math.abs(strafe) + Math.abs(turn), 1); double frontLeftPower = (power + strafe + turn) / denominator; double backLeftPower = (power - strafe + turn) / denominator; double frontRightPower = (power - strafe - turn) / denominator; double backRightPower = (power + strafe - turn) / denominator; setDrivePowers(frontLeftPower, backLeftPower, frontRightPower, backRightPower); } public void setDrivePowers(double frontLeftPower, double backLeftPower, double frontRightPower, double backRightPower) { leftFront.setPower(frontLeftPower); leftRear.setPower(backLeftPower); rightFront.setPower(frontRightPower); rightRear.setPower(backRightPower); } } } The mecanum drivetrain allows for much more freedom of movement, and makes quick manuevers during the teleop period possible.","title":"Holonomic"},{"location":"intro/","text":"All Java programming for FTC is done through Android Studio, which you can download here . Instructions for setting up your FTC project can be found here . Game Manual 0 has a great guide for getting started with Java and covers elementary concepts such as defining hardware devices. I recommend you go through that guide first as it is how I got my first introduction to FTC programming. The guide can be found here . Once you have a good grasp of the fundamentals, we can begin going over some more advanced topics.","title":"Introduction"},{"location":"pid/","text":"PID control is one of the most common control systems you will see in robotics, and FTC specifically. Three values need to be tuned (Proportional, Integral and Derivative) which alter the behavior of the controller. Earlier, we saw an example of a proportional controller, which can be seen modelled below: The Kp value is the only one altering the controller's input. Alternatively, a PID controller uses 2 more values, Ki and Kd. The PID controller can be modelled as seen below: To gain a comprehensive understanding of the math behind PID controllers, I recommend you watch this Youtube video series, which explains the fundamental mathematical concept very well. Lets go ahead and program a simple PID controller in Java: public class PID { private double Kp; private double Ki; private double Kd; private double integralSum = 0.0; private double lastError = 0.0; private ElapsedTime timer; public PID(double p, double i, double d) { Kp = p; Ki = i; Kd = d; timer = new ElapsedTime(); timer.reset(); } public double getValue(double error) { double dT = timer.seconds(); double derivative = (error - lastError) / dT; // sum all the error over time integralSum += (error * dT); // return the out value eg. motor power double out = (Kp * error) + (Ki * integralSum) + (Kd * derivative); lastError = error; timer.reset(); return out; } } Although you can code your own PID controller like done above, I recommend you instead use the PID controller from FTCLib, a library for First Tech Challenge robotics. Follow the Kookybotz tutorial video to see how you can setup FTCLib in your project. A rule of thumb when programming is to never reinvent the wheel. There are tons of incredible libraries and tools out there for your use, created by the amazing FTC community. Why try to make something from scratch when you can use a pre-existing tool that will save you a lot of time?","title":"PID Control"},{"location":"roadrunner/","text":"Even armed with knowledge about control theory, programming autons can be tough. Roadrunner is a libary that simplifies the process, and gives you the ability to create efficient and accurate autons. The library also offers an easy way to tune drive constants such as track width, and PID for various controllers that it uses. The documentation for Roadrunner can be found here . It is very important that Roadrunner is tuned properly for it to work well. I recommend that you spend time thoroughly following the tuning steps in the documentation I linked above. Once everything is tuned, creating paths is not very difficult. I have a few tips from my own experience using Roadrunner in the past. Firstly, Roadrunner provides a sample mecanum drive class that can be used without much need for change. However, I recommend that you use the same drive class that you use in TeleOp. This means that changes you make in one drive class do not have to be replicated in the other. In order to use you own drive class, simply copy over the Roadrunner methods from the Sample Mecanum Drive class into your own drive class. Second, after you have gained a good understanding of how trajectories, and trajectory sequences work, make sure to use asynchronous trajectories whenever possible. This allows for the movement of other parts of the robot such as a lift or arm to happen simultaneously to the movement of the drive.","title":"Roadrunner"}]}